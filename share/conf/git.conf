<git>
	DefaultMainline = master

	<info>
		user <<---
			git config github.user
		---

		status <<---
			git status
		---

		is_dirty <<---
			{ %status !~ /working directory clean/ }
		---

		has_staged <<---
			{ %status =~ /Changes to be committed:/ }
		---

		mod_files <<---
			git status -s | awk '{print $2}'
		---

		staged_files <<---
			git status -s | awk '$0 ~ /^[A-Z]/ {print $2}'
		---

		cur_branch <<---
			git rev-parse --abbrev-ref HEAD
		---

		branches <<---
			git branch | cut -c3-
		---

		remote_branches <<---
			git branch -r | cut -c3-
		---

		tags <<---
			git tag
		---
	</info>

	<commands>
		stat <<---
			>
			> %status
			>
			git stash list
			>
		---

		show-branches <<---
			git branch
		---

		unbranch <<---
			git checkout %Mainline
		---

		# remember: %info methods record the state as of the beginning of the command
		# therefore, %is_dirty will remain true (if it was before) even after the stash
		sync <<---
			%is_dirty -> git stash save -u
			git pull --rebase
			%is_dirty -> git stash pop
		---

		push <<---
			= sync
			git push
		---

		stage <<---
			git add -i .
		---

		unstage <<---
			# for some reason, git reset HEAD always returns 1 instead of 0 ...
			%files  -> git reset HEAD %files || :
			!%files -> git reset HEAD %staged_files || :
		---

		unget <<---
			git checkout -- %files
		---

		resolved <<---
			# for some reason, git reset HEAD always returns 1 instead of 0 ...
			git reset HEAD %files || :
		---

		commit <<---
			%files && %has_staged -> ! Cannot commit specific files with staged changes
			!%files && !%has_staged -> ! Either stage changes or specify files to commit
			%has_staged -> git commit -v
			!%has_staged -> git commit -v %files
		---

		commit-fix <<---
			`git branch -r --contains HEAD` -> ! Cannot fix last commit; it has already been pushed.
			git commit -v --amend
		---
	</commands>

</git>

<CustomCommand stash>
	Description = Stash uncommitted changes to make working copy clean
	Verify = project
	<Trailing message>
		description = optional message to identify stash
		singular = message
		qty = 0..1
	</Trailing>

	action <<---
		git stash save -u "%message"
		= stat
	---
</CustomCommand>

<CustomCommand unstash>
	Description = Restore previously stashed changes
	Verify = project
	<Trailing name>
		description = optional name ("stash@{1}") or number ("1") to identify stash
		singular = name
		qty = 0..1
	</Trailing>

	action <<---
		# make it so you can just go `vc unstash 1` and get `git stash pop "stash@{1}"`
		STASH=my $f = %name[0] // ''; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f
		# "s necessary because stash names have curly braces in them, for some insane reason
		'$STASH' -> git stash pop "$STASH"
		!'$STASH' -> git stash pop
	---
</CustomCommand>
