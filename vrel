#! /usr/bin/perl

use strict;
use warnings;

use VCtools::Base;
use VCtools::Args;
use VCtools::Common;


# dispatch tables for release methods
our $dispatch =
{
	local	=>	{
					get_mtime	=>	\&local_mtime,
					rm_file		=>	\&local_rm,
					cp_file		=>	\&local_cp,
					fix_group	=>	\&local_chgrp,
				},
	rsh		=>	{
					get_mtime	=>	\&rsh_mtime,
					rm_file		=>	\&rsh_rm,
					cp_file		=>	\&rcp,
					fix_group	=>	\&rsh_chgrp,
				},
	ssh		=>	{
					get_mtime	=>	\&ssh_mtime,
					rm_file		=>	\&ssh_rm,
					cp_file		=>	\&scp,
					fix_group	=>	\&ssh_chgrp,
				},
};


#################################
# OPTIONS AND ARGUMENTS
#################################

VCtools::switch('info_only', 'I', 'only show release information');
VCtools::args('files', 'list', 'file(s) to release');
VCtools::getopts();

my @files = VCtools::files();


#################################
# CHECK FOR ERRORS
#################################

our $proj = VCtools::verify_files_and_group(@files);

# can't release a directory (at least at this time)
if (grep { -d } @files)
{
	VCtools::fatal_error("can only release files (not directories)");
}

# need a valid release method
our $rmethod = VCtools::get_proj_directive($proj, 'ReleaseMethod',
		'<none specified>');
VCtools::fatal_error("unknown release method $rmethod")
		unless exists $dispatch->{$rmethod};

# get statuses for everything at once (quicker that way)
VCtools::cache_file_status(@files);

# all files must have status "nothing"
# any other status should block release
# quick method for checking this: number of files with status 'nothing'
# should exactly == total number of files
unless (@files == VCtools::get_all_with_status('nothing'))
{
	VCtools::fatal_error("not all files are properly checked in");
}

=not_working_with_svn_yet
# probably _shouldn't_ release it if anyone else has it checked out
if (cvs::lockers($module))
{
	print STDERR "$me: others have this module checked out\n";
	exit 1 unless get_yn("Release it anyway?");
}

# write access to the file is suspicious enough to vomit on
if (-w $module)
{
	print STDERR "$me: won't release a file unless it is read-only\n";
	print STDERR "  (check permissions and run cdiff)\n";
	exit 1;
}
=cut



#################################
# MAIN
#################################


foreach my $file (@files)
{
	my $rpath = VCtools::release_path($file);
	VCtools::info_msg(VCtools::info_only() ? "release info for" : "releasing",
			"file $file ...");

	unless (defined release($file, $rpath))
	{
		VCtools::prompt_to_continue("release of $file to $rpath failed!");
	}
}


#################################
# SUBS
#################################


# return value:
#	true: file was successfully released
#	false: file was not released with user approval
#	undef: system error while trying to release
sub release
{
	my ($file, $rpath) = @_;
	my $machine = $rpath =~ s/^(\w+):// ? $1 : "localhost";
	print STDERR "production file is $rpath\n" if DEBUG >= 2;

	VCtools::info_msg(-INDENT => VCtools::info_only() ? "on:" : "now releasing to:", $machine, "path", $rpath);

	# make sure existing file is older
	my $vc_date = (stat $file)[9];
	my $prod_file_date
			= $dispatch->{$rmethod}->{get_mtime}->($machine, $rpath);
	print STDERR "comparing prod date $prod_file_date to vc date $vc_date\n"
			if DEBUG >= 4;
	if (VCtools::info_only())
	{
		if ($prod_file_date == 0)
		{
			VCtools::info_msg(-INDENT => "file does not yet exist in production",
					"(needs to be released)");
		}
		elsif ($prod_file_date == $vc_date)
		{
			VCtools::info_msg(-INDENT => "production file has same date; no need to release");
		}
		elsif ($prod_file_date > $vc_date)
		{
			VCtools::info_msg(-INDENT => "production file is newer; check for unauthorized modification");
		}
		else					# file in production is indeed older
		{
			VCtools::info_msg(-INDENT => "production file is old; need to release");
		}
		return 1;
	}
	unless ($prod_file_date < $vc_date)
	{
		VCtools::info_msg(-INDENT => "current production file is",
				$prod_file_date == $vc_date ? "the same age as" : "newer than", "the development file");
		return 0 unless VCtools::yesno("Release it anyway?");
	}

	# remove old file
	$dispatch->{$rmethod}->{rm_file}->($machine, $rpath);

	# copy new file
	VCtools::info_msg(-INDENT => "copying $file to $rpath") if VCtools::verbose();
	$dispatch->{$rmethod}->{cp_file}->($machine, $file, $rpath);

	# make sure file has the correct group
	my $group = VCtools::project_group($proj);
	VCtools::info_msg(-INDENT => "changing group on $file to $group") if VCtools::verbose();
	$dispatch->{$rmethod}->{fix_group}->($machine, $rpath, $group);

	# successfully released
	return 1;
}


sub local_mtime
{
	return (stat($_[1]))[9] || 0;
}

sub rsh_mtime
{
	return `rsh $_[0] perl -e 'print (stat(\$ARGV[0]))[9] || 0' $_[1]`;
}

sub ssh_mtime
{
	return `ssh $_[0] perl -e 'print (stat(\$ARGV[0]))[9] || 0' $_[1]`;
}


sub local_rm
{
	unlink($_[1]);
}

sub rsh_rm
{
	my $v = VCtools::verbose() ? "-v" : "";
	system("rsh $_[0] /bin/rm $v -f $_[1]");
}

sub ssh_rm
{
	my $v = VCtools::verbose() ? "-v" : "";
	system("ssh $_[0] /bin/rm $v -f $_[1]");
}


sub local_cp
{
	system("cp -p $_[1] $_[2]");
}

sub rcp
{
	system("rcp -p $_[1] $_[0]:$_[2]");
}

sub scp
{
	system("scp -p $_[1] $_[0]:$_[2]");
}


sub local_chgrp
{
	system("chgrp $_[2] $_[1]");
}

sub rsh_chgrp
{
	system("rsh $_[0] chgrp $_[2] $_[1]");
}

sub ssh_chgrp
{
	system("ssh $_[0] chgrp $_[2] $_[1]");
}
