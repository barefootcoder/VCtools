#! /usr/bin/perl

use strict;

#use Barefoot::debug;							# comment out for production

use DirHandle;
use Getopt::Std;
use Cwd qw<getcwd>;

use Barefoot::cvs;
use Barefoot::base;

my $me = $0;
$me =~ s@^.*/@@;

$| = true;										# autoflush STDOUT

# default values
my $ignore_errors = false;
my $recurse = false;
my $fix_write_access = false;
my $verbose = false;
my $cvsroot = $::ENV{CVSROOT};

#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

my $opt = {};
getopts('irfd:v', $opt);
cvs::set_cvsroot($opt->{d}) if defined $opt->{d};
$ignore_errors = true if defined $opt->{i};
$recurse = true if defined $opt->{r};
$fix_write_access = true if defined $opt->{f};
$verbose = true if defined $opt->{v};


#################################
# CHECK FOR ERRORS
#################################

cvs::check_general_errors();


#################################
# MAIN
#################################

my $retval = 0;							# default to no errors

if (@ARGV == 0)							# no args passed, default to .
{
	@ARGV = ( "." );
}

# ideally, we would just call cvs::lockers() on each potential module
# however, this would generate one cvs call for each file, which could be
# slow as hell, especially if the CVS server is a remote one
# consequently, we'll just generate one call here and parse the output
# ourselves.  we don't duplicate any code, really, because we call the same
# internal function cvs::lockers() calls (i.e., cvs::_interpet_editors_output,
# not cvs::_get_lockers).  we won't miss any functionality, because the only
# thing we're circumventing is the cache, and that would be empty anyway.
# also, doing it this way saves us having to expand the directories ourselves.

my %modules;

my $ed = cvs::execute_and_get_output("editors", @ARGV,
		{ VERBOSE => $verbose, RECURSE => $recurse });
my $curmod = "";
while ( <$ed> )
{
	my ($module, $user) = cvs::_interpret_editors_output();

	if (defined $user)
	{
		if (defined $module)
		{
			# new module; change curmod and init hash element
			$curmod = $module;
			$modules{$curmod} = {};
		}

		# save user as a locker (value not really used)
		$modules{$curmod}->{$user} = true;
	}
	else
	{
		# unknown module
		$modules{$module} = undef;
	}
}
close($ed);


# now cycle through the files and print 'em all out

# this is the same way cvs::user_is_a_locker() does it
my $username = $ENV{USER} || $ENV{USERNAME};

foreach (sort keys %modules)
{
	my $lockers = $modules{$_};

	# unknown module
	unless (defined $lockers)
	{
		print "$_: WARNING! unknown module (not in CVS)\n";
		$retval |= 2;
		next;
	}

	# print lockers if there are any
	print "$_: ", join(", ", keys %$lockers), "\n" if %$lockers;
	
	# if user isn't one of the lockers, check to see if has write perms
	if (not exists $lockers->{$username} and -w $_)
	{
		if ($fix_write_access)
		{
			my $difference = system("cvs diff $_ >/dev/null");
			if ($difference)
			{
				system("get $_");
				if ($verbose)
				{
					print "NOTE: locked $_ since it had changes\n";
				}
			}
			else
			{
				system("chmod a-w $_");
				if ($verbose)
				{
					print "NOTE: restored $_ since it had no changes\n";
				}
			}
		}
		else
		{
			print "$_: WARNING! module is writable, ",
					"but you don't have it locked\n";
			$retval |= 1;
		}
	}
}


exit $retval;							# will be 1 if any errors


#################################
# SUBS
#################################
