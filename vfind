#! /usr/bin/perl

use strict;
use warnings;

use Data::Dumper;

use VCtools::Base;
use VCtools::Args;
use VCtools::Common;


#################################
# OPTIONS AND ARGUMENTS
#################################

VCtools::switch('current_dir', 'c', 'start from . (default: start from root project dir)');
VCtools::args('dirs', 'optlist', 'directory/ies to search (default: search all from starting dir)');
VCtools::action('print', 'print filename (only)  (this is the default action)');
VCtools::action('file', 'consider a file only if its basename contains this string', 'string');
VCtools::action('grep', 'search file for (Perl regex) pattern (also prints filename)', 'pattern');
VCtools::action('dirfind', 'find closest matching dirname (exact matches and least depth preferred)', 'dirname');
VCtools::getopts();

# remember, directories are files too
my @files = VCtools::dirs();


#################################
# CHECK FOR ERRORS
#################################

my $proj = VCtools::check_common_errors();


#################################
# MAIN
#################################

my $projdir = VCtools::project_dir($proj);
# this helps regex'es go faster
my $projdir_qr = qr[^$projdir/];
print STDERR "figuring proj is $proj and dir is $projdir\n" if DEBUG >= 2;

if (VCtools::current_dir())
{
	if (not @files)
	{
		@files = ('.');
	}
}
else
{
	if (@files)
	{
		$_ = "$projdir/$_" foreach @files;
	}
	else
	{
		@files = ($projdir);
	}
}

# assume false
my $retval = 0;

# do this one outside the loop since it really only needs to be done once
my $grep_pattern = VCtools::grep();
if ($grep_pattern)
{
	eval { $grep_pattern = qr/$grep_pattern/ }
			or VCtools::fatal_error("illegal grep pattern: $@");
}

# ditto
my $dirmatch = VCtools::dirfind();
if ($dirmatch)
{
	eval { $dirmatch = qr{(?:^|/)$dirmatch(.*)$} }
			# this shouldn't ever happen, I don't think
			or VCtools::fatal_error("can't turn dirname into a pattern: $@");
}
our %possible_dirs;

# and ditto again
my $filematch = VCtools::file();
if ($filematch)
{
	eval { $filematch = qr{[^/]*\Q$filematch\E[^/]*$} }
			# even less likely for this to happen IMHO
			or VCtools::fatal_error("can't turn filename into a pattern: $@");
}

foreach (VCtools::get_all_files(@files))
{
	next if $filematch and not /$filematch/;

	if ($grep_pattern)
	{
		$retval |= grep_file($_, $grep_pattern);
	}
	elsif ($dirmatch)
	{
		$retval |= dir_find($_, $dirmatch);
	}
	else
	{
		# doesn't really matter if they specified -print or not;
		# this is the default action
		$retval |= print_file($_, "\n");
	}
}


# dirfind option doesn't print anything as it goes along, so print result here
if ($dirmatch)
{
	if (%possible_dirs)
	{
		print "possible_dirs: ", Dumper(\%possible_dirs) if DEBUG >= 3;

		my @dirs = sort {
			$possible_dirs{$a} <=> $possible_dirs{$b} || $a cmp $b
		} keys %possible_dirs;
		print "dirs: @dirs\n" if DEBUG >= 2;

		print "$dirs[0]\n";
	}
	else
	{
		# oops, no possibles
		VCtools::warning("no directories found");
	}
}

# if everything is true, that means no errors,
# so reverse the sense of our $retval
exit(not $retval);


#################################
# SUBS
#################################


sub print_file
{
	my ($file, $trailer) = @_;
	$trailer ||= '';

	$file =~ s/$projdir_qr//;
	$file .= "/" if -d $file;
	print "$file$trailer";

	# print is always true
	return 1;
}


sub grep_file
{
	my ($file, $pattern) = @_;
	my $retval = 0;

	if (-f)
	{
		if (not open(IN, $_))
		{
			VCtools::warning("can't open file $_");
			return 0;
		}

		while ( <IN> )
		{
			if ( /$pattern/ )
			{
				$retval = 1;

				# using -grep and -print at the same time indicates that we only want the file name
				if (VCtools::print())
				{
					print_file($file);
					print "\n";
					last;
				}
				else
				{
					print_file($file, ":");
					print;
				}
			}
		}
		close(IN);
	}

	return $retval;
}


sub dir_find
{
	my ($file, $pattern) = @_;

	return 0 unless -d $_;
	return 0 unless /$dirmatch/;

	# (note: pattern we built for $dirmatch captures any trailing chars as $1, so we can tell exact
	# matches by checking $1 for having zero length)
	my $exact = length($1) == 0;
	
	# count the number of subdirs
	# this allows us to rank choices by how "deep" they are
	my $depth = s@/@/@g || 0;

	# we want exact matches to rank higher than partials
	# thus we add an arbitrary large number to non-exact matches, making them drop low in the sorting
	$possible_dirs{$_} = $depth + !$exact * 100;

	return 1;
}
