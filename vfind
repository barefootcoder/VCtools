#! /usr/bin/perl

###########################################################################
#
# vfind
#
###########################################################################
#
# This command performs recursive searches on files and directories in the repository, ignoring the same files
# that VC commands would ignore, as well as the VC control directories.  You can use it to find files, find
# directories, or "grep" all files (except that this uses Perl regexen rather than basic or extended ones).
#
# #########################################################################
#
# All the code herein is released under the Artistic License
#		( http://www.perl.com/language/misc/Artistic.html )
# Copyright (c) 2004-2008 Barefoot Software, Copyright (c) 2004-2006 ThinkGeek
#
###########################################################################

use strict;
use warnings;

use Data::Dumper;

use VCtools::Base;
use VCtools::Args;
use VCtools::Common;


#################################
# OPTIONS AND ARGUMENTS
#################################

VCtools::switch('current_dir', 'c', 'start from . (default: start from root project dir)');
VCtools::args('dirs', 'optlist', 'directory/ies to search (default: search all from starting dir)');
VCtools::action('print', 'print filename (only)  (this is the default action)');
VCtools::action('file', 'consider a file only if its basename contains this string', 'string');
VCtools::action('grep', 'search file for (Perl regex) pattern (also prints filename)', 'pattern');
VCtools::action('dirfind', 'find closest matching dirname (exact matches and least depth preferred)', 'dirname');
VCtools::getopts();
print STDERR "finished with opts\n" if DEBUG >= 5;

# remember, directories are files too
my @files = VCtools::dirs();


#################################
# CHECK FOR ERRORS
#################################

my $proj = VCtools::check_common_errors();


#################################
# MAIN
#################################

my $projdir = VCtools::project_dir($proj);
# this helps regex'es go faster
my $projdir_qr = qr[^$projdir/];
print STDERR "figuring proj is $proj and dir is $projdir\n" if DEBUG >= 2;

if (VCtools::current_dir())
{
	if (not @files)
	{
		@files = ('.');
	}
}
else
{
	chdir $projdir or VCtools::fatal_error("can't change to TLD of project");
	@files = ('.') unless @files;
}

# assume false
my $retval = 0;

# do this one outside the loop since it really only needs to be done once
my $grep_pattern = VCtools::grep();
if ($grep_pattern)
{
	eval { $grep_pattern = qr/$grep_pattern/ } or VCtools::fatal_error("illegal grep pattern: $@");
}
print STDERR "set grep pattern to $grep_pattern\n" if DEBUG >= 2;

# ditto
my $dirmatch = VCtools::dirfind();
if ($dirmatch)
{
	# this shouldn't ever happen, I don't think
	print STDERR "about to eval dirmatch ...\n" if DEBUG >= 5;
	eval { $dirmatch = qr{(?:^|/)$dirmatch(.*)$} } or VCtools::fatal_error("can't turn dirname into a pattern: $@");
}
print STDERR "set dirmatch to $dirmatch\n" if DEBUG >= 2;
our %possible_dirs;

# and ditto again
my $filematch = VCtools::file();
if ($filematch)
{
	# even less likely for this to happen IMHO
	eval { $filematch = qr{[^/]*\Q$filematch\E[^/]*$} } or VCtools::fatal_error("can't turn filename into a pattern: $@");
}

foreach (VCtools::get_all_files(@files))
{
	exit if VCtools::pretend();											# no point in going further if running under -p
	next if $filematch and not /$filematch/;

	if ($grep_pattern)
	{
		$retval |= grep_file($_, $grep_pattern);
	}
	elsif ($dirmatch)
	{
		$retval |= dir_find($_, $dirmatch);
	}
	else
	{
		# doesn't really matter if they specified -print or not;
		# this is the default action
		$retval |= print_file($_, "\n");
	}
}


# dirfind option doesn't print anything as it goes along, so print result here
if ($dirmatch)
{
	if (%possible_dirs)
	{
		print "possible_dirs: ", Dumper(\%possible_dirs) if DEBUG >= 3;

		my @dirs = sort {
			$possible_dirs{$a} <=> $possible_dirs{$b} || $a cmp $b
		} keys %possible_dirs;
		print "dirs: @dirs\n" if DEBUG >= 2;

		print "$dirs[0]\n";
	}
	else
	{
		# oops, no possibles
		VCtools::warning("no directories found");
	}
}

# if everything is true, that means no errors,
# so reverse the sense of our $retval
exit(not $retval);


#################################
# SUBS
#################################


sub print_file
{
	my ($file, $trailer) = @_;
	$trailer ||= '';

	$file =~ s/$projdir_qr//;
	$file .= "/" if -d $file;
	print "$file$trailer";

	# print is always true
	return 1;
}


sub grep_file
{
	my ($file, $pattern) = @_;
	print STDERR "grep_file($file, $pattern)\n" if DEBUG >= 4;
	my $retval = 0;

	if (-f $file)
	{
		if (-T $file)
		{
			if (not open(IN, $file))
			{
				VCtools::warning("can't open file $file");
				return 0;
			}

			while ( <IN> )
			{
				if ( /$pattern/ )
				{
					$retval = 1;

					# using -grep and -print at the same time indicates that we only want the file name
					if (VCtools::print())
					{
						print_file($file);
						print "\n";
						last;
					}
					else
					{
						print_file($file, ":");
						print;
					}
				}
			}
			close(IN);
		}
		else
		{
			VCtools::warning("skipped binary file $file");
		}
	}

	return $retval;
}


sub dir_find
{
	my ($file, $pattern) = @_;

	return 0 unless -d $file;
	return 0 unless /$dirmatch/;

	# (note: pattern we built for $dirmatch captures any trailing chars as $1, so we can tell exact
	# matches by checking $1 for having zero length)
	my $exact = length($1) == 0;
	
	# count the number of subdirs
	# this allows us to rank choices by how "deep" they are
	my $depth = s@/@/@g || 0;

	# we want exact matches to rank higher than partials
	# thus we add an arbitrary large number to non-exact matches, making them drop low in the sorting
	$possible_dirs{$file} = $depth + !$exact * 100;

	return 1;
}
