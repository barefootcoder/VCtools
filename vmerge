#! /usr/bin/perl

use strict;
use warnings;

use VCtools::Base;
use VCtools::Args;
use VCtools::Common;
use VCtools::Config;


#################################
# OPTIONS AND ARGUMENTS
#################################

VCtools::switch('branch', 'b', 'merge from this branch (default: merge from trunk)', 'branchname');
VCtools::switch('revision', 'V', 'merge changes up to this revision (default is HEAD)', 'revno');
VCtools::args('files', 'list', 'file(s) (or directory/ies) to merge');
VCtools::getopts();

# remember, directories are files too
my @files = VCtools::files();


#################################
# CHECK FOR ERRORS
#################################

my $proj = VCtools::verify_files_and_group(@files);
print STDERR "project is $proj\n" if DEBUG >= 2;

# get statuses for everything at once (quicker that way)
# like vbranch, vmerge is always recursive
VCtools::cache_file_status(@files, { DONT_RECURSE => 0 });

# pull out which files are modified
my @mod_files = VCtools::get_all_with_status('modified');
print STDERR "mod files are: ", join(', ', @mod_files), "\n" if DEBUG >= 3;

my $branch = VCtools::branch();									# if we're merging from a branch, use that
if ($branch)
{
	VCtools::fatal_error("no such branch $branch") unless VCtools::branch_exists_in_vc($proj, $branch);
}
print STDERR "determined branch to be $branch\n" if DEBUG >= 2;

my $curbranch;
foreach (@files)												# important for all files to be in the same branch
{
	my $br = VCtools::get_branch($_) || 'TRUNK';
	print STDERR "got $br back from get_branch\n" if DEBUG >= 3;

	if ($curbranch)
	{
		VCtools::fatal_error("files are from at least two branches: $curbranch, $br") unless $br eq $curbranch;
	}
	$curbranch = $br;
}

print STDERR "curbranch is $curbranch and branch is $branch\n" if DEBUG >= 2;
if ($curbranch eq 'TRUNK' and not $branch)
{
	VCtools::fatal_error("cannot merge from trunk to trunk");
}
elsif ($branch and $curbranch eq $branch)
{
	VCtools::fatal_error("cannot merge from branch $branch to itself");
}

my $merge_commit = VCtools::get_proj_directive($proj, 'MergeCommit');
VCtools::fatal_error("too dangerous to merge without a MergeCommit directive; fix your config and try again")
		unless $merge_commit;

my $start = VCtools::branch_point_revno($proj, $branch || $curbranch);
my $prev_merge = VCtools::prev_merge_point($proj, $branch || $curbranch, @files);
print STDERR "determined branch point to be $start and previous merge point to be $prev_merge\n" if DEBUG >= 3;
$start = $prev_merge + 1 if $prev_merge > $start;
print STDERR "determined starting revision to be $start\n" if DEBUG >= 2;

my $end = VCtools::revision() || VCtools::head_revno($proj);
print STDERR "determined ending revision to be $end\n" if DEBUG >= 2;

VCtools::prompt_to_continue("will merge revisions $start through $end from " . ($branch ? "branch $branch" : "trunk"),
		"If this does not sound right, please do not continue.",
		"Also, for maximum safety you should always vsync before you vmerge.",
		"If you haven't vsync'ed lately, please stop now and do so before running again.");


#################################
# MAIN
#################################

use constant BAK_EXT => '.mrgbak';

VCtools::backup_full_project($proj, { ext => BAK_EXT });

if (@mod_files)
{
	# we don't want to commit modified files; rather, we want to commit the merge of what they would have been if they
	# hadn't been modified ... thus (for modified files only), backup, revert, merge, commit, restore, then merge again
	VCtools::create_backup_files(@mod_files, { ext => BAK_EXT });
	VCtools::revert_files(@mod_files);
}

VCtools::merge_from_branch($proj, $branch, $start, $end, @files);

# now figure out what got modified, if there are any conflicts, etc
CONFLICT_RESOLUTION:
{
	VCtools::cache_file_status(@files, { DONT_RECURSE => 0 });
	my @problem_files;
	push @problem_files, VCtools::get_all_with_status($_) foreach qw< conflict broken locked outdated >;
	if (@problem_files)
	{
		VCtools::info_msg("WARNING! There are problem files resulting from the merge.");
		VCtools::list_files($proj, "have one of the following statuses: conflict, broken, locked, outdated", @problem_files);
		VCtools::info_msg("The merge cannot continue unless these problems are resolved.");
		VCtools::info_msg("If you like, you can use another window to attempt to resolve the problems then say 'y' below.");
		if (VCtools::yesno("Do you want to check for problem files again?"))
		{
			redo CONFLICT_RESOLUTION;
		}

		if (yesno_no_default("Do you wish to restore the project to pre-merge status?"))
		{
			VCtools::restore_project_backup($proj, { ext => BAK_EXT });
		}
		else
		{
			VCtools::info_msg("Your project is in an unstable state.  After further investigation, you may wish to");
			VCtools::info_msg(-INDENT => "manually restore the complete project backup located at "
					. VCtools::full_project_backup_name($proj, { ext => BAK_EXT }));
		}

		exit 1;
	}
}
my @new_mod_files = VCtools::get_all_with_status('modified');
print STDERR "new mod files are: ", join(', ', @new_mod_files), "\n" if DEBUG >= 3;

VCtools::info_msg("NOTE! It is *strongly* advised that you go to another window and check the success of this operation.");
VCtools::info_msg(-INDENT => "If you feel the merge was successful, you should continue (say 'yes' below).");
VCtools::info_msg(-INDENT => "If you feel the merge failed, you should revert (say 'no' below) and try again later.");

if (yesno_no_default("Do you wish to continue by committing the merge operation?"))
{
	my $commit_msg = "$merge_commit\nMerged revisions $start:$end from " . ($branch ? "branch $branch" : "trunk");
	VCtools::commit_files($proj, @new_mod_files, { MERGE => scalar(@new_mod_files), MESSAGE => $commit_msg });
}
else
{
	# they don't like it; let's put everything back
	VCtools::restore_project_backup($proj, { ext => BAK_EXT });
	exit 1;
}

# finish special processing of modified files
if (@mod_files)
{
	VCtools::restore_backup_files(@mod_files, { ext => BAK_EXT, overwrite => 1 });
	VCtools::merge_from_branch($proj, $branch, $start, $end, @mod_files);
}

print "done\n";


#################################
# SUBS
#################################


# a special version of yesno() that doesn't allow default values
sub yesno_no_default
{
	loop:
	{
		print "$_[0]  [y/n] ";
		my $answer = <STDIN>;

		redo loop unless $answer;
		return 1 if $answer =~ /^y/i;
		return 0 if $answer =~ /^n/i;
		redo loop;
	}
}
