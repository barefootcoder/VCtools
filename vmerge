#! /usr/bin/perl

###########################################################################
#
# vmerge
#
###########################################################################
#
# This command merges changes from a branch to the trunk, or from the trunk to a branch.  THIS COMMAND DOES
# NOT YET WORK WITH CVS!
#
# #########################################################################
#
# All the code herein is released under the Artistic License
#		( http://www.perl.com/language/misc/Artistic.html )
# Copyright (c) 2005-2008 Barefoot Software, Copyright (c) 2005-2005 ThinkGeek
#
###########################################################################

use strict;
use warnings;

use VCtools::Base;
use VCtools::Args;
use VCtools::Common;
use VCtools::Config;


#################################
# OPTIONS AND ARGUMENTS
#################################

VCtools::switch('branch', 'b', 'merge from this branch (default: merge from trunk)', 'branchname');
VCtools::switch('revision', 'V', 'merge changes up to this revision (default is HEAD)', 'revno');
VCtools::args('files', 'list', 'file(s) (or directory/ies) to merge');
VCtools::getopts();

# remember, directories are files too
my @files = VCtools::files();


#################################
# CHECK FOR ERRORS
#################################

VCtools::verify_files_and_group(@files);
my $merge_commit = VCtools::check_branch_errors();
print STDERR "project is $VCtools::PROJ\n" if DEBUG >= 2;

# get statuses for everything at once (quicker that way)
# like vbranch, vmerge is always recursive
VCtools::cache_file_status(@files, { DONT_RECURSE => 0, SHOW_BRANCHES => 1 });

# pull out which files are modified
my @mod_files = VCtools::get_all_with_status('modified');
print STDERR "mod files are: ", join(', ', @mod_files), "\n" if DEBUG >= 3;

my $from_branch = VCtools::branch();							# if we're merging from a branch, use that
if ($from_branch)
{
	VCtools::fatal_error("no such branch $from_branch") unless VCtools::branch_exists_in_vc($from_branch);
}
else
{
	$from_branch = 'TRUNK';
}
print STDERR "determined from branch to be $from_branch\n" if DEBUG >= 2;

my $to_branch;
foreach (@files)												# important for all files to be in the same branch
{
	my $br = VCtools::get_branch($_) || 'TRUNK';
	print STDERR "got $br back from get_branch\n" if DEBUG >= 3;

	if ($to_branch)
	{
		VCtools::fatal_error("files are from at least two branches: $to_branch, $br") unless $br eq $to_branch;
	}
	$to_branch = $br;
}

print STDERR "to branch is $to_branch and from branch is $from_branch\n" if DEBUG >= 2;
if ($from_branch eq 'TRUNK' and $to_branch eq 'TRUNK')
{
	VCtools::fatal_error("cannot merge from trunk to trunk");
}
elsif ($from_branch eq $to_branch)
{
	VCtools::fatal_error("cannot merge from branch $from_branch to itself");
}

my $start = VCtools::branch_point_revno($from_branch eq 'TRUNK' ? $to_branch : $from_branch);
my $prev_merge = VCtools::prev_merge_point($from_branch, $to_branch, @files);
print STDERR "determined branch point to be $start and previous merge point to be $prev_merge\n" if DEBUG >= 3;
# I thought this should be $prev_merge + 1, but the Subversion mailing lists seem to indicate this is wrong
$start = $prev_merge if $prev_merge > $start;
print STDERR "determined starting revision to be $start\n" if DEBUG >= 2;

my $end = VCtools::revision() || VCtools::head_revno();
print STDERR "determined ending revision to be $end\n" if DEBUG >= 2;

VCtools::prompt_to_continue("will merge revisions $start through $end from "
				. ($from_branch eq 'TRUNK' ? "trunk" : "branch $from_branch") . " into "
				. ($to_branch eq 'TRUNK' ? "trunk" : "branch $to_branch"),
		"If this does not sound right, please do not continue.",
		"Also, for maximum safety you should always vsync before you vmerge.",
		"If you haven't vsync'ed lately, please stop now and do so before running again.");


#################################
# MAIN
#################################

use constant BAK_EXT => '.mrgbak';

VCtools::backup_full_project({ ext => BAK_EXT });

if (@mod_files)
{
	# we don't want to commit modified files; rather, we want to commit the merge of what they would have been if they
	# hadn't been modified ... thus (for modified files only), backup, revert, merge, commit, restore, then merge again
	VCtools::create_backup_files(@mod_files, { ext => BAK_EXT });
	VCtools::revert_files(@mod_files);
}

VCtools::merge_from_branch($from_branch, $start, $end, @files);

# now figure out what got modified, if there are any conflicts, etc
CONFLICT_RESOLUTION:
{
	VCtools::cache_file_status(@files, { DONT_RECURSE => 0 });
	my @problem_files;
	push @problem_files, VCtools::get_all_with_status($_) foreach qw< conflict broken locked outdated >;
	if (@problem_files)
	{
		VCtools::info_msg("WARNING! There are problem files resulting from the merge.");
		VCtools::list_files("have one of the following statuses: conflict, broken, locked, outdated", @problem_files);
		VCtools::info_msg("The merge cannot continue unless these problems are resolved.");
		VCtools::info_msg("If you like, you can use another window to attempt to resolve the problems then say 'y' below.");
		if (VCtools::yesno("Do you want to check for problem files again?"))
		{
			redo CONFLICT_RESOLUTION;
		}

		if (yesno_no_default("Do you wish to restore the project to pre-merge status?"))
		{
			VCtools::restore_project_backup({ ext => BAK_EXT });
		}
		else
		{
			VCtools::info_msg("Your project is in an unstable state.  After further investigation, you may wish to");
			VCtools::info_msg(-INDENT => "manually restore the complete project backup located at "
					. VCtools::full_project_backup_name({ ext => BAK_EXT }));
		}

		exit 1;
	}
}
my @new_mod_files = VCtools::get_all_with_status('modified');
print STDERR "new mod files are: ", join(', ', @new_mod_files), "\n" if DEBUG >= 3;

VCtools::info_msg("NOTE! It is *strongly* advised that you go to another window and check the success of this operation.");
VCtools::info_msg(-INDENT => "If you feel the merge was successful, you should continue (say 'yes' below).");
VCtools::info_msg(-INDENT => "If you feel the merge failed, you should revert (say 'no' below) and try again later.");

if (yesno_no_default("Do you wish to continue by committing the merge operation?"))
{
	my $commit_msg = "$merge_commit\nMerged revisions $start:$end from "
			. ($from_branch eq 'TRUNK' ? "trunk" : "branch $from_branch");
	# HACK! when first arg removed from lib, remove here
	VCtools::commit_files(undef, @new_mod_files, { MERGE => scalar(@new_mod_files), MESSAGE => $commit_msg });
}
else
{
	# they don't like it; let's put everything back
	VCtools::restore_project_backup({ ext => BAK_EXT });
	exit 1;
}

# finish special processing of modified files
if (@mod_files)
{
	VCtools::restore_backup_files(@mod_files, { ext => BAK_EXT, overwrite => 1 });
	VCtools::merge_from_branch($from_branch, $start, $end, @mod_files);
}

print "done\n";


#################################
# SUBS
#################################


# a special version of yesno() that doesn't allow default values
sub yesno_no_default
{
	loop:
	{
		print "$_[0]  [y/n] ";
		my $answer = <STDIN>;

		redo loop unless $answer;
		return 1 if $answer =~ /^y/i;
		return 0 if $answer =~ /^n/i;
		redo loop;
	}
}
